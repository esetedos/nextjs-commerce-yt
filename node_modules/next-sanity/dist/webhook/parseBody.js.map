{"version":3,"file":"parseBody.js","sources":["../../src/webhook/parseBody.ts"],"sourcesContent":["import type {SanityDocument} from '@sanity/types'\nimport {isValidSignature, SIGNATURE_HEADER_NAME} from '@sanity/webhook'\nimport type {NextApiRequest} from 'next'\nimport type {NextRequest} from 'next/server'\n\nimport {_readBody as readBody} from './readBody'\n\n/** @public */\nexport type ParsedBody<T> = {\n  /**\n   * If a secret is given then it returns a boolean. If no secret is provided then no validation is done on the signature, and it'll return `null`\n   */\n  isValidSignature: boolean | null\n  body: T | null\n}\n\n/**\n * @deprecated Use `ParsedBody` instead\n * @public\n */\nexport type ParseBody<Body = SanityDocument> = ParsedBody<Body>\n/**\n * Handles parsing the body JSON, and validating its signature. Also waits for Content Lake eventual consistency so you can run your queries\n * without worrying about getting stale data.\n * @public\n */\nexport async function parseBody<Body = SanityDocument>(\n  req: NextApiRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency?: boolean,\n): Promise<ParsedBody<Body>>\n/**\n * Handles parsing the body JSON, and validating its signature. Also waits for Content Lake eventual consistency so you can run your queries\n * without worrying about getting stale data.\n * @public\n */\nexport async function parseBody<Body = SanityDocument>(\n  req: NextRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency?: boolean,\n): Promise<ParsedBody<Body>>\n/**\n * Handles parsing the body JSON, and validating its signature. Also waits for Content Lake eventual consistency so you can run your queries\n * without worrying about getting stale data.\n * @public\n */\n// eslint-disable-next-line require-await\nexport async function parseBody<Body = SanityDocument>(\n  req: NextApiRequest | NextRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency: boolean = true,\n): Promise<ParsedBody<Body>> {\n  return 'text' in req\n    ? parseAppBody(req, secret, waitForContentLakeEventualConsistency)\n    : parsePageBody(req, secret, waitForContentLakeEventualConsistency)\n}\n\nasync function parsePageBody<Body = SanityDocument>(\n  req: NextApiRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency: boolean = true,\n): Promise<ParsedBody<Body>> {\n  let signature = req.headers[SIGNATURE_HEADER_NAME]\n  if (Array.isArray(signature)) {\n    signature = signature[0]\n  }\n  if (!signature) {\n    console.error('Missing signature header')\n    return {body: null, isValidSignature: null}\n  }\n\n  if (req.readableEnded) {\n    throw new Error(\n      `Request already ended and the POST body can't be read. Have you setup \\`export {config} from 'next-sanity/webhook' in your webhook API handler?\\``,\n    )\n  }\n\n  const body = await readBody(req)\n  const validSignature = secret ? await isValidSignature(body, signature, secret.trim()) : null\n\n  if (validSignature !== false && waitForContentLakeEventualConsistency) {\n    await new Promise((resolve) => setTimeout(resolve, 1000))\n  }\n\n  return {\n    body: body.trim() ? JSON.parse(body) : null,\n    isValidSignature: validSignature,\n  }\n}\n\n/**\n * @deprecated Use `ParsedBody` instead\n * @public\n */\nexport type ParseAppBody<Body = SanityDocument> = ParsedBody<Body>\n/**\n * Handles parsing the body JSON, and validating its signature. Also waits for Content Lake eventual consistency so you can run your queries\n * without worrying about getting stale data.\n * @deprecated Use `parseBody` instead\n * @public\n */\nexport async function parseAppBody<Body = SanityDocument>(\n  req: NextRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency: boolean = true,\n): Promise<ParsedBody<Body>> {\n  const signature = req.headers.get(SIGNATURE_HEADER_NAME)!\n  if (!signature) {\n    console.error('Missing signature header')\n    return {body: null, isValidSignature: null}\n  }\n\n  const body = await req.text()\n  const validSignature = secret ? await isValidSignature(body, signature, secret.trim()) : null\n\n  if (validSignature !== false && waitForContentLakeEventualConsistency) {\n    await new Promise((resolve) => setTimeout(resolve, 3000))\n  }\n\n  return {\n    body: body.trim() ? JSON.parse(body) : null,\n    isValidSignature: validSignature,\n  }\n}\n"],"names":["async","parseBody","req","secret","waitForContentLakeEventualConsistency","arguments","length","undefined","parseAppBody","signature","headers","SIGNATURE_HEADER_NAME","Array","isArray","console","error","body","isValidSignature","readableEnded","Error","readBody","validSignature","trim","Promise","resolve","setTimeout","JSON","parse","parsePageBody","get","text"],"mappings":"wHA+CAA,eAAsBC,EACpBC,EACAC,GAE2B,IAD3BC,IAAAC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GAEO,MAAA,SAAUH,EACbM,EAAaN,EAAKC,EAAQC,GAIhCJ,eACEE,EACAC,GAE2B,IAD3BC,IAAAC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GAEII,EAAYP,EAAIQ,QAAQC,GACxBC,MAAMC,QAAQJ,KAChBA,EAAYA,EAAU,IAExB,IAAKA,EAEH,OADAK,QAAQC,MAAM,4BACP,CAACC,KAAM,KAAMC,iBAAkB,MAGxC,GAAIf,EAAIgB,cACN,MAAM,IAAIC,MACR,mJAIE,MAAAH,QAAaI,EAASlB,GACtBmB,EAAiBlB,QAAec,EAAiBD,EAAMP,EAAWN,EAAOmB,QAAU,MAElE,IAAnBD,GAA4BjB,SACxB,IAAImB,SAASC,GAAYC,WAAWD,EAAS,OAG9C,MAAA,CACLR,KAAMA,EAAKM,OAASI,KAAKC,MAAMX,GAAQ,KACvCC,iBAAkBI,EAEtB,CAlCMO,CAAc1B,EAAKC,EAAQC,EACjC,CA8CAJ,eAAsBQ,EACpBN,EACAC,GAE2B,IAD3BC,IAAAC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GAEA,MAAMI,EAAYP,EAAIQ,QAAQmB,IAAIlB,GAClC,IAAKF,EAEH,OADAK,QAAQC,MAAM,4BACP,CAACC,KAAM,KAAMC,iBAAkB,MAGlC,MAAAD,QAAad,EAAI4B,OACjBT,EAAiBlB,QAAec,EAAiBD,EAAMP,EAAWN,EAAOmB,QAAU,KAMlF,OAJgB,IAAnBD,GAA4BjB,SACxB,IAAImB,SAASC,GAAYC,WAAWD,EAAS,OAG9C,CACLR,KAAMA,EAAKM,OAASI,KAAKC,MAAMX,GAAQ,KACvCC,iBAAkBI,EAEtB"}