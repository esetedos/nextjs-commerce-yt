{"version":3,"file":"parseBody.cjs","sources":["../../src/webhook/parseBody.ts"],"sourcesContent":["import type {SanityDocument} from '@sanity/types'\nimport {isValidSignature, SIGNATURE_HEADER_NAME} from '@sanity/webhook'\nimport type {NextApiRequest} from 'next'\nimport type {NextRequest} from 'next/server'\n\nimport {_readBody as readBody} from './readBody'\n\n/** @public */\nexport type ParsedBody<T> = {\n  /**\n   * If a secret is given then it returns a boolean. If no secret is provided then no validation is done on the signature, and it'll return `null`\n   */\n  isValidSignature: boolean | null\n  body: T | null\n}\n\n/**\n * @deprecated Use `ParsedBody` instead\n * @public\n */\nexport type ParseBody<Body = SanityDocument> = ParsedBody<Body>\n/**\n * Handles parsing the body JSON, and validating its signature. Also waits for Content Lake eventual consistency so you can run your queries\n * without worrying about getting stale data.\n * @public\n */\nexport async function parseBody<Body = SanityDocument>(\n  req: NextApiRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency?: boolean,\n): Promise<ParsedBody<Body>>\n/**\n * Handles parsing the body JSON, and validating its signature. Also waits for Content Lake eventual consistency so you can run your queries\n * without worrying about getting stale data.\n * @public\n */\nexport async function parseBody<Body = SanityDocument>(\n  req: NextRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency?: boolean,\n): Promise<ParsedBody<Body>>\n/**\n * Handles parsing the body JSON, and validating its signature. Also waits for Content Lake eventual consistency so you can run your queries\n * without worrying about getting stale data.\n * @public\n */\n// eslint-disable-next-line require-await\nexport async function parseBody<Body = SanityDocument>(\n  req: NextApiRequest | NextRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency: boolean = true,\n): Promise<ParsedBody<Body>> {\n  return 'text' in req\n    ? parseAppBody(req, secret, waitForContentLakeEventualConsistency)\n    : parsePageBody(req, secret, waitForContentLakeEventualConsistency)\n}\n\nasync function parsePageBody<Body = SanityDocument>(\n  req: NextApiRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency: boolean = true,\n): Promise<ParsedBody<Body>> {\n  let signature = req.headers[SIGNATURE_HEADER_NAME]\n  if (Array.isArray(signature)) {\n    signature = signature[0]\n  }\n  if (!signature) {\n    console.error('Missing signature header')\n    return {body: null, isValidSignature: null}\n  }\n\n  if (req.readableEnded) {\n    throw new Error(\n      `Request already ended and the POST body can't be read. Have you setup \\`export {config} from 'next-sanity/webhook' in your webhook API handler?\\``,\n    )\n  }\n\n  const body = await readBody(req)\n  const validSignature = secret ? await isValidSignature(body, signature, secret.trim()) : null\n\n  if (validSignature !== false && waitForContentLakeEventualConsistency) {\n    await new Promise((resolve) => setTimeout(resolve, 1000))\n  }\n\n  return {\n    body: body.trim() ? JSON.parse(body) : null,\n    isValidSignature: validSignature,\n  }\n}\n\n/**\n * @deprecated Use `ParsedBody` instead\n * @public\n */\nexport type ParseAppBody<Body = SanityDocument> = ParsedBody<Body>\n/**\n * Handles parsing the body JSON, and validating its signature. Also waits for Content Lake eventual consistency so you can run your queries\n * without worrying about getting stale data.\n * @deprecated Use `parseBody` instead\n * @public\n */\nexport async function parseAppBody<Body = SanityDocument>(\n  req: NextRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency: boolean = true,\n): Promise<ParsedBody<Body>> {\n  const signature = req.headers.get(SIGNATURE_HEADER_NAME)!\n  if (!signature) {\n    console.error('Missing signature header')\n    return {body: null, isValidSignature: null}\n  }\n\n  const body = await req.text()\n  const validSignature = secret ? await isValidSignature(body, signature, secret.trim()) : null\n\n  if (validSignature !== false && waitForContentLakeEventualConsistency) {\n    await new Promise((resolve) => setTimeout(resolve, 3000))\n  }\n\n  return {\n    body: body.trim() ? JSON.parse(body) : null,\n    isValidSignature: validSignature,\n  }\n}\n"],"names":["async","parseAppBody","req","secret","waitForContentLakeEventualConsistency","arguments","length","undefined","signature","headers","get","SIGNATURE_HEADER_NAME","console","error","body","isValidSignature","text","validSignature","trim","Promise","resolve","setTimeout","JSON","parse","Array","isArray","readableEnded","Error","readBody","parsePageBody"],"mappings":"iIAqGAA,eAAsBC,EACpBC,EACAC,GAE2B,IAD3BC,IAAAC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GAEA,MAAMG,EAAYN,EAAIO,QAAQC,IAAIC,EAAqBA,uBACvD,IAAKH,EAEH,OADAI,QAAQC,MAAM,4BACP,CAACC,KAAM,KAAMC,iBAAkB,MAGlC,MAAAD,QAAaZ,EAAIc,OACjBC,EAAiBd,QAAeY,mBAAiBD,EAAMN,EAAWL,EAAOe,QAAU,KAMlF,OAJgB,IAAnBD,GAA4Bb,SACxB,IAAIe,SAASC,GAAYC,WAAWD,EAAS,OAG9C,CACLN,KAAMA,EAAKI,OAASI,KAAKC,MAAMT,GAAQ,KACvCC,iBAAkBE,EAEtB,0CA5EAjB,eACEE,EACAC,GAE2B,IAD3BC,IAAAC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GAEO,MAAA,SAAUH,EACbD,EAAaC,EAAKC,EAAQC,GAIhCJ,eACEE,EACAC,GAE2B,IAD3BC,IAAAC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GAEIG,EAAYN,EAAIO,QAAQE,EAAqBA,uBAC7Ca,MAAMC,QAAQjB,KAChBA,EAAYA,EAAU,IAExB,IAAKA,EAEH,OADAI,QAAQC,MAAM,4BACP,CAACC,KAAM,KAAMC,iBAAkB,MAGxC,GAAIb,EAAIwB,cACN,MAAM,IAAIC,MACR,mJAIE,MAAAb,QAAac,YAAS1B,GACtBe,EAAiBd,QAAeY,mBAAiBD,EAAMN,EAAWL,EAAOe,QAAU,MAElE,IAAnBD,GAA4Bb,SACxB,IAAIe,SAASC,GAAYC,WAAWD,EAAS,OAG9C,MAAA,CACLN,KAAMA,EAAKI,OAASI,KAAKC,MAAMT,GAAQ,KACvCC,iBAAkBE,EAEtB,CAlCMY,CAAc3B,EAAKC,EAAQC,EACjC"}