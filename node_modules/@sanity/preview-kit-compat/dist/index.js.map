{"version":3,"file":"index.js","sources":["../../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/rng.js","../../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/stringify.js","../../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/native.js","../../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/v4.js","../../channels/src/constants.ts","../../channels/src/helpers.ts","../../channels/src/node.ts","../src/useDocumentsInUse.ts","../../visual-editing-helpers/dist/hooks.js"],"sourcesContent":["// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","import type { ChannelMsgType } from './types'\n\nexport const RESPONSE_TIMEOUT = 1000\nexport const HEARTBEAT_INTERVAL = 1000\nexport const HANDSHAKE_INTERVAL = 500\n\nexport const INTERNAL_MSG_TYPES = [\n  'channel/disconnect',\n  'channel/response',\n  'channel/heartbeat',\n] satisfies ChannelMsgType[]\n\nexport const HANDSHAKE_MSG_TYPES = [\n  'handshake/syn',\n  'handshake/syn-ack',\n  'handshake/ack',\n] satisfies ChannelMsgType[]\n","import { HANDSHAKE_MSG_TYPES, INTERNAL_MSG_TYPES } from './constants'\nimport { ChannelMsgType, HandshakeMsgType, InternalMsgType } from './types'\n\nexport const isInternalMessage = (\n  type: ChannelMsgType | InternalMsgType,\n): type is InternalMsgType => {\n  return INTERNAL_MSG_TYPES.some((t) => t === type)\n}\n\nexport const isHandshakeMessage = (\n  type: ChannelMsgType | InternalMsgType,\n): type is HandshakeMsgType => {\n  return HANDSHAKE_MSG_TYPES.some((t) => t === type)\n}\n","import { v4 as uuid } from 'uuid'\n\nimport { isHandshakeMessage, isInternalMessage } from './helpers'\nimport {\n  ChannelMsg,\n  ChannelsNode,\n  ChannelsNodeChannel,\n  ChannelsNodeOptions,\n  ChannelStatus,\n  HandshakeMsgType,\n  InternalMsgType,\n  ProtocolMsg,\n  ToArgs,\n} from './types'\n\nexport function createChannelsNode<T extends ChannelMsg>(\n  config: ChannelsNodeOptions<T>,\n): ChannelsNode<T> {\n  const inFrame = window.self !== window.top\n\n  const channel: ChannelsNodeChannel = {\n    buffer: [],\n    id: null,\n    origin: null,\n    status: 'connecting',\n  }\n\n  function flush() {\n    const toFlush = [...channel.buffer]\n    channel.buffer.splice(0, channel.buffer.length)\n    toFlush.forEach(({ type, data }) => {\n      send(type, data)\n    })\n  }\n\n  function send<K extends T['type']>(\n    type: K | InternalMsgType | HandshakeMsgType,\n    data?: Extract<T, { type: K }>['data'],\n  ) {\n    if (\n      !isHandshakeMessage(type) &&\n      !isInternalMessage(type) &&\n      (channel.status === 'connecting' || channel.status === 'reconnecting')\n    ) {\n      channel.buffer.push({ type, data })\n      return\n    }\n\n    if (channel.id && channel.origin) {\n      const msg: ProtocolMsg<T> = {\n        connectionId: channel.id,\n        data,\n        domain: 'sanity/channels',\n        from: config.id,\n        id: uuid(),\n        to: config.connectTo,\n        type,\n      }\n\n      try {\n        parent.postMessage(msg, {\n          targetOrigin: channel.origin,\n        })\n      } catch (e) {\n        throw new Error(`Failed to postMessage '${msg.id}' on '${config.id}'`)\n      }\n    }\n  }\n\n  function isValidMessageEvent(\n    e: MessageEvent,\n  ): e is MessageEvent<ProtocolMsg<T>> {\n    const { data } = e\n    return (\n      data.domain === 'sanity/channels' &&\n      data.to === config.id &&\n      data.from === config.connectTo &&\n      data.type !== 'channel/response'\n    )\n  }\n\n  function handleEvents(e: MessageEvent) {\n    if (isValidMessageEvent(e)) {\n      const { data } = e\n      if (isHandshakeMessage(data.type) && data.data) {\n        if (data.type === 'handshake/syn') {\n          channel.origin = e.origin\n          channel.id = data.data.id as string\n          setConnectionStatus('connecting')\n          send('handshake/syn-ack', { id: channel.id })\n          return\n        }\n        if (data.type === 'handshake/ack' && data.data.id === channel.id) {\n          setConnectionStatus('connected')\n          return\n        }\n      } else if (\n        data.connectionId === channel.id &&\n        e.origin === channel.origin\n      ) {\n        if (data.type === 'channel/disconnect') {\n          setConnectionStatus('disconnected')\n          return\n        } else {\n          const args = [data.type, data.data] as ToArgs<T>\n          config.onEvent?.(...args)\n          send('channel/response', { responseTo: data.id })\n        }\n        return\n      }\n    }\n  }\n\n  function disconnect() {\n    if (['disconnected'].includes(channel.status)) return\n    // send('channel/disconnect', { id: channel.id })\n    setConnectionStatus('disconnected')\n  }\n\n  function destroy() {\n    disconnect()\n    window.removeEventListener('message', handleEvents, false)\n  }\n\n  function setConnectionStatus(next: ChannelStatus) {\n    channel.status = next\n    config?.onStatusUpdate?.(next)\n    if (next === 'connected') {\n      flush()\n    }\n  }\n\n  function initialise() {\n    window.addEventListener('message', handleEvents, false)\n    setConnectionStatus('connecting')\n  }\n\n  initialise()\n\n  function sendPublic<K extends T['type']>(\n    type: K,\n    data?: Extract<T, { type: K }>['data'],\n  ) {\n    send(type, data)\n  }\n\n  return {\n    destroy,\n    inFrame,\n    send: sendPublic,\n  }\n}\n","import { type ChannelsNode, createChannelsNode } from '@sanity/channels'\nimport type { ContentSourceMapDocuments } from '@sanity/client/csm'\nimport {\n  type VisualEditingConnectionIds,\n  type VisualEditingMsg,\n} from '@sanity/visual-editing-helpers'\nimport { useEffect, useState } from 'react'\n\n/**\n * Reports the documents in use on the page to the Presentation Tool, if a connection can be established.\n * @internal\n */\nexport function useDocumentsInUse(\n  documentsInUse: Map<string, ContentSourceMapDocuments[number]>,\n  projectId: string,\n  dataset: string,\n): void {\n  const [channel, setChannel] = useState<\n    ChannelsNode<VisualEditingMsg> | undefined\n  >()\n  const [connected, setConnected] = useState(false)\n  useEffect(() => {\n    if (window.self === window.top) {\n      return\n    }\n    const channel = createChannelsNode<VisualEditingMsg>({\n      id: 'preview-kit' satisfies VisualEditingConnectionIds,\n      connectTo: 'presentation' satisfies VisualEditingConnectionIds,\n      onStatusUpdate(status) {\n        if (status === 'connected') {\n          setConnected(true)\n        } else if (status === 'disconnected') {\n          setConnected(false)\n        }\n      },\n    })\n    const timeout = setTimeout(() => setChannel(channel), 0)\n    return () => {\n      clearTimeout(timeout)\n      channel.destroy()\n      setChannel(undefined)\n    }\n  }, [dataset, projectId])\n\n  const changedKeys = JSON.stringify(Array.from(documentsInUse.keys()))\n  useEffect(() => {\n    if (changedKeys !== '[]' && channel && connected) {\n      channel.send('preview-kit/documents', {\n        projectId,\n        dataset,\n        perspective: 'previewDrafts',\n        documents: Array.from(documentsInUse.values()),\n      })\n    }\n  }, [changedKeys, channel, connected, dataset, documentsInUse, projectId])\n}\n","import{useMemo as e,useState as n,useCallback as t,useEffect as i,useSyncExternalStore as r}from\"react\";function o(n){const t=e((()=>JSON.stringify(n||{})),[n]);return e((()=>JSON.parse(t)),[t])}function s(e){const{refreshInterval:o}=e,s=function(){const[e,t]=n(!1);i((()=>{t(navigator.onLine);const e=()=>t(!0),n=()=>t(!1);return window.addEventListener(\"online\",e),window.addEventListener(\"offline\",n),()=>{window.removeEventListener(\"online\",e),window.removeEventListener(\"offline\",n)}}),[]);const o=r(u,(()=>document.visibilityState),(()=>\"hidden\"));if(!e)return!0;if(\"hidden\"===o)return!0;return!1}(),[d,c]=n(\"hit\"),f=t((()=>(c(\"inflight\"),()=>c(\"hit\"))),[]);return i((()=>{if(!o||\"hit\"!==d)return;const e=setTimeout((()=>c(\"stale\")),o);return()=>clearTimeout(e)}),[o,d]),i((()=>{if(\"hit\"!==d)return;const e=()=>c(\"stale\");return window.addEventListener(\"focus\",e),()=>window.removeEventListener(\"focus\",e)}),[o,d]),i((()=>{s&&\"hit\"===d&&c(\"stale\"),s||\"stale\"!==d||c(\"refresh\")}),[s,d]),[d,f]}function u(e){return document.addEventListener(\"visibilitychange\",e),()=>document.removeEventListener(\"visibilitychange\",e)}export{o as useQueryParams,s as useRevalidate};//# sourceMappingURL=hooks.js.map\n"],"names":["useState","useEffect","useMemo","useSyncExternalStore","useCallback","getRandomValues","rnds8","Uint8Array","rng","crypto","bind","Error","byteToHex","i","push","toString","slice","native","randomUUID","v4","options","buf","offset","rnds","random","arr","unsafeStringify","INTERNAL_MSG_TYPES","HANDSHAKE_MSG_TYPES","isInternalMessage","type","some","t","isHandshakeMessage","createChannelsNode","config","inFrame","window","self","top","channel","buffer","id","origin","status","send","data","msg","connectionId","domain","from","uuid","to","connectTo","parent","postMessage","targetOrigin","e","handleEvents","isValidMessageEvent","setConnectionStatus","args","onEvent","responseTo","next","onStatusUpdate","toFlush","splice","length","forEach","flush","addEventListener","destroy","includes","removeEventListener","useDocumentsInUse","documentsInUse","projectId","dataset","setChannel","connected","setConnected","timeout","setTimeout","clearTimeout","changedKeys","JSON","stringify","Array","keys","perspective","documents","values","o","n","parse","s","refreshInterval","navigator","onLine","e4","n2","r","u","document","visibilityState","d","c","f","e3"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}