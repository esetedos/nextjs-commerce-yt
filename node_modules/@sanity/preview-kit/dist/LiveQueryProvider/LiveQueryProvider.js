import{jsxs as e,jsx as t,Fragment as r}from"react/jsx-runtime";import{applySourceDocuments as n}from"@sanity/client/csm";import{useRevalidate as o,useDocumentsInUse as s}from"@sanity/preview-kit-compat";import{vercelStegaSplit as c}from"@vercel/stega";import{LRUCache as i}from"lru-cache";import{applyPatch as a}from"mendoza";import{memo as u,useState as l,useEffect as d,useCallback as f,startTransition as p,useMemo as m}from"react";import{defineStoreContext as h}from"../context.js";const g=new i({max:500}),v=u((function(r){const{children:n,refreshInterval:o=1e4,token:s}=r;if(!r.client)throw new Error("Missing a `client` prop with a configured Sanity client instance");const[c]=l((()=>{const{requestTagPrefix:e,resultSourceMap:t}=r.client.config();return r.client.withConfig({requestTagPrefix:e||"sanity.preview-kit",resultSourceMap:"withKeyArraySelector"!==t||"withKeyArraySelector",...s&&{token:s,useCdn:!1,perspective:"previewDrafts",ignoreBrowserTokenWarning:!0}})})),[i]=l((()=>r.logger));d((()=>{i&&i.log("[@sanity/preview-kit]: With the current configuration you can expect that: Updates that can be traced using Content Source Maps will be applied in real-time. Other updates will be applied every ".concat(o,"ms."))}),[i,o]);const[a,u]=l([]),[g]=l((()=>new Map)),v=function(e){const[t]=l((()=>new Map)),r=f(((r,n,o,s)=>{t.has(r)||(t.set(r,{query:n,params:o,listeners:new Set}),p((()=>e((e=>e.includes(r)?e:[...e,r])))));const c=t.get(r);if(!c||!c.listeners)throw new TypeError("Inconsistent cache for key: "+r);const{listeners:i}=c;return i.add(s),()=>{i.delete(s),0===i.size&&(t.delete(r),p((()=>e((e=>e.includes(r)?e.filter((e=>e!==r)):e)))))}}),[t,e]);return m((()=>({cache:t,subscribe:r})),[t,r])}(u),[S]=l((()=>function(e,t,r){const n=j(t,r);g.has(n)||g.set(n,{result:e,resultSourceMap:{}});return{subscribe:e=>{const o=v.subscribe(n,t,r,e);return()=>o()},getSnapshot:()=>{var e;return null==(e=g.get(n))?void 0:e.result}}})),[b,I]=l([]),[M]=l((()=>new Map)),N=f((e=>{var t;const r=new Set;if(M.clear(),null==(t=e.documents)?void 0:t.length)for(const t of e.documents)r.add(t._id),M.set(t._id,t);p((()=>I((e=>{const t=Array.from(new Set([...e,...r]));return JSON.stringify(t.sort())===JSON.stringify(e.sort())?e:t}))))}),[M]);return e(h.Provider,{value:S,children:[n,t(w,{cache:v.cache,client:c,setTurboIds:I,snapshots:g,turboIds:b,docsInUse:M}),a.map((e=>{if(!v.cache.has(e))return null;const{query:r,params:n,listeners:s}=v.cache.get(e);return t(y,{client:c,listeners:s,params:n,query:r,refreshInterval:o,snapshots:g,turboIdsFromSourceMap:N},e)}))]})}));v.displayName="LiveStoreProvider";const y=u((function(e){const{client:t,refreshInterval:r,query:n,params:s,listeners:c,snapshots:i,turboIdsFromSourceMap:a}=e,{projectId:u,dataset:f}=m((()=>{const{projectId:e,dataset:r}=t.config();return{projectId:e,dataset:r}}),[t]),[p,h]=l(null);if(p)throw p;const[g,v]=o({refreshInterval:r}),y="refresh"===g||"inflight"===g;return d((()=>{if(!y)return;let e=!1;const r=new AbortController;const o=v();return async function(){const{signal:o}=r,{result:l,resultSourceMap:d}=await t.fetch(n,s,{signal:o,filterResponse:!1});if(!o.aborted){i.set(j(n,s),{result:M(u,f,l,d),resultSourceMap:null!=d?d:{}}),d&&a(d);for(const e of c.values())e();e=!0}}().catch((e=>{"AbortError"!==e.name&&h(e)})).finally(o),()=>{e||r.abort()}}),[t,f,c,s,u,n,y,i,v,a]),null}));function S(e,t,r){return"".concat(e,"-").concat(t,"-").concat(r)}y.displayName="QuerySubscription";const w=u((function(e){const{client:n,snapshots:o,cache:c,turboIds:i,setTurboIds:u,docsInUse:f}=e,{projectId:h,dataset:v}=m((()=>{const{projectId:e,dataset:t}=n.config();return{projectId:e,dataset:t}}),[n]);d((()=>{var e,t;const r=new Set;f.clear();for(const{query:n,params:s}of c.values()){const c=j(n,s),i=o.get(c);if(i&&(null==(t=null==(e=i.resultSourceMap)?void 0:e.documents)?void 0:t.length))for(const e of i.resultSourceMap.documents)r.add(e._id),f.set(e._id,e)}const n=[...r].sort();JSON.stringify(i)!==JSON.stringify(n)&&p((()=>u(n)))}),[c,u,o,i,f]),s(f,h,v);const[y,w]=l([]);d((()=>{const e=new Set(y.flat()),t=new Set;for(const r of i)e.has(r)||g.has(S(h,v,r))||t.add(r);const r=[...t].slice(0,10);0!==r.length&&p((()=>w((e=>[...e.slice(-10),r]))))}),[y,v,h,i]);const[I,N]=l();return d((()=>{const e=n.listen("*",{},{events:["mutation"],effectFormat:"mendoza",includePreviousRevision:!1,includeResult:!1,tag:"turbo"}).subscribe((e=>{var t,r;if("mutation"!==e.type||!(null==(r=null==(t=e.effects)?void 0:t.apply)?void 0:r.length))return;const n=S(h,v,e.documentId),o=g.peek(n);if(o){const t={...o};delete t._rev;const r=a(t,e.effects.apply);g.set(n,r)}p((()=>N(e.documentId)))}));return()=>e.unsubscribe()}),[n,v,h]),d((()=>{var e,t,r;if(!I||!i.includes(I))return;const n=[];for(const[r,s]of o.entries())(null==(t=null==(e=s.resultSourceMap)?void 0:e.documents)?void 0:t.length)&&(s.result=M(h,v,s.result,s.resultSourceMap),n.push(r));for(const e of n){const t=null==(r=c.get(e))?void 0:r.listeners;if(t)for(const e of t)e()}p((()=>N(void 0)))}),[c,v,I,h,o,i]),t(r,{children:y.map((e=>t(b,{client:n,projectId:h,dataset:v,ids:e},JSON.stringify(e))))})}));w.displayName="Turbo";const b=u((function(e){const{client:t,projectId:r,dataset:n,ids:o}=e;return d((()=>{const e=o.filter((e=>!g.has(S(r,n,e))));0!==e.length&&t.getDocuments(e).then((e=>{for(const t of e)t&&(null==t?void 0:t._id)&&g.set(S(r,n,t._id),t)}),console.error)}),[t,n,o,r]),null}));b.displayName="GetDocuments";let I=!1;function M(e,t,r,o){return o?n(r,o,(r=>{if(!r._projectId)return g.get(S(e,t,r._id));I||(console.warn("Cross dataset references are not supported yet, ignoring source document",r),I=!0)}),((e,t)=>{let{previousValue:r}=t;if("string"==typeof e&&"string"==typeof r){const{encoded:t}=c(r),{cleaned:n}=c(e);return"".concat(t).concat(n)}return e})):r}function j(e,t){return"".concat(e,"-").concat(JSON.stringify(t))}export{v as default};
//# sourceMappingURL=LiveQueryProvider.js.map
